{
    "bubble_sort": {
        "description": "Bubble sort is a way to put numbers in order. You compare two numbers at a time and swap them if they're not in the right order. Keep doing this until all the numbers are in the correct order. It's like making the biggest numbers \"bubble\" to the end.",
        "instructions": "Click on the bubbles in the green area to pop them. Put them in the right order (from smallest to biggest) and Beat the Algorithm! The Reset button deletes your current attempt. Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move take 500 ms or 1/2 of a second.",
            "intermediate": "Intermediate makes each move take 200 ms or 1/5 of a second.",
            "hard": "Hard makes each move take 100 ms or 1/10 of a second.",
            "impossible": "Impossible makes each move take 10 ms or 1/100 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Bubble sort is a simple sorting algorithm that repeatedly steps through a list of elements, compares adjacent elements, and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements \"bubble\" to the top of the list. This process is repeated until the entire list is sorted.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Compare the first element with the second element.",
                "step3": "If the first element is greater than the second element, swap them.",
                "step4": "Otherwise, leave them as they are.",
                "step5": "Move to the next pair of adjacent elements.",
                "step6": "Repeat steps 2-5 until you reach the end of the list.",
                "step7": "The largest element will now be at the end of the list.",
                "step8": "Repeat steps 2-7 for all elements except the last one.",
                "step9": "Each pass places the next largest element in its correct position.",
                "step10": "Continue until no more swaps are needed.",
                "step11": "The list is now sorted."
            },
            "timeComplexity": "Bubble sort has a time complexity of O(n^2) in the average and worst cases, where n is the number of elements in the list. It is not considered an efficient sorting algorithm for large lists.",
            "spaceComplexity": "Bubble sort has a space complexity of O(1), as it performs sorting in-place without requiring additional memory beyond the input array.",
            "realWorldApplications": "Bubble sort is rarely used in production code due to its poor performance, but it finds applications in educational contexts for teaching sorting concepts, and in scenarios with very small datasets or nearly sorted data where its simplicity is beneficial."
        }
    },
    "selection_sort": {
        "description": "Selection sort is a way to put numbers in order. You find the smallest number and put it in the first position. Then, you find the next smallest number and put it in the second position. Repeat this until all the numbers are sorted.",
        "instructions": "Select a number by clicking it. This will select the value and you can put it in the correct box. Put them in the right order (from smallest to biggest) and Beat the Algorithm! Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move take 700 ms or 7/10 of a second.",
            "intermediate": "Intermediate makes each move take 500 ms or 1/2 of a second.",
            "hard": "Hard makes each move take 300 ms or 3/10 of a second.",
            "impossible": "Impossible makes each move take 10 ms or 1/100 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Selection sort is a simple sorting algorithm that repeatedly finds the minimum element from the unsorted part of the list and places it at the beginning. The algorithm divides the list into two parts: the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty, and the entire list is unsorted.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Find the minimum element in the unsorted part of the list.",
                "step3": "Identify the leftmost element in the unsorted part.",
                "step4": "Swap the minimum element with the leftmost unsorted element.",
                "step5": "The minimum element is now in its correct position in the sorted part.",
                "step6": "Move the boundary of the sorted part one element to the right.",
                "step7": "Repeat step 2: Find the minimum in the remaining unsorted portion.",
                "step8": "Repeat step 3: Identify the new leftmost unsorted element.",
                "step9": "Repeat step 4: Swap the new minimum with the leftmost unsorted element.",
                "step10": "Continue this process until the entire list is sorted."
            },
            "timeComplexity": "Selection sort has a time complexity of O(n^2) in the average and worst cases, where n is the number of elements in the list. Similar to bubble sort, it is not considered an efficient sorting algorithm for large lists. But, it is considered more efficient than bubble sort because of the number of swaps done by each.",
            "spaceComplexity": "Selection sort has a space complexity of O(1), as it performs sorting in-place without requiring additional memory beyond the input array.",
            "realWorldApplications": "Selection sort is useful when the cost of swapping elements is high, as it performs at most n-1 swaps. It is commonly used in scenarios with small datasets, embedded systems with limited memory, and when stability is not a requirement."
        }
    },
    "heap_sort": {
        "description": "Heap sort is a comparison-based sorting algorithm that uses a min heap data structure to sort elements. It involves two main steps: building a min heap and repeatedly extracting the minimum element from the heap to place it in the sorted part of the list.",
        "instructions": "Select a number by clicking it. This will select the value and you can put it in the correct box. If there is a value in that box, that value will be put into the selection box. Put them in the right order (from smallest to biggest) and Beat the Algorithm! Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move take 3 seconds.",
            "intermediate": "Intermediate makes each move take 2 seconds.",
            "hard": "Hard makes each move take 1 second.",
            "impossible": "Impossible makes each move take 100 ms or 1/10 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Heap sort is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements. It involves two main steps: building a heap and repeatedly extracting the maximum element from the heap to place it in the sorted part of the list.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Identify the heap property: each parent node must be smaller than or equal to its child nodes.",
                "step3": "Start from the last non-leaf node in the list.",
                "step4": "Perform a heapify operation on the current node.",
                "step5": "Compare the node with its left child.",
                "step6": "Compare the node with its right child.",
                "step7": "Swap with the smaller child if necessary.",
                "step8": "Work backwards towards the root node.",
                "step9": "Repeat heapify operations until the entire heap is built.",
                "step10": "The smallest element is now at the root of the heap.",
                "step11": "Extract the root element and place it in the sorted part.",
                "step12": "Replace the root with the last element in the unsorted part.",
                "step13": "Reduce the heap size by 1.",
                "step14": "Heapify the new root to maintain the heap property.",
                "step15": "Repeat steps 11-14 until the heap size becomes 1.",
                "step16": "All elements are now sorted."
            },
            "timeComplexity": "Heap sort has a time complexity of O(n log n) in all cases, where n is the number of elements in the list. The build heap operation takes O(n) time, and each extraction of the minimum element takes O(log n) time. Since we perform these operations n times, the overall time complexity is O(n log n). Heap sort has a relatively efficient runtime, making it suitable for large lists.",
            "spaceComplexity": "Heap sort has a space complexity of O(1), as it performs sorting in-place using the input array itself to build the heap structure.",
            "realWorldApplications": "Heap sort is widely used in priority queues, operating systems for job scheduling, and embedded systems. It is also used in algorithms that need to find the k largest or smallest elements efficiently, and in external sorting where memory is limited."
        }
    },
    "merge_sort": {
        "description": "Merge sort works by dividing the list into smaller parts, sorting them individually, and then merging them back together to obtain a sorted list. It uses the idea of dividing and merging to efficiently sort the numbers.",
        "instructions": "Select a number by clicking it. This will select the value and put it in the white list of values on top. You can remove the values from the list on top by clicking it. Put them in the right order (from smallest to biggest) and Beat the Algorithm! Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move take 2 1/2 seconds.",
            "intermediate": "Intermediate makes each move take 1 second.",
            "hard": "Hard makes each move take half a second.",
            "impossible": "Impossible makes each move take 100 ms or 1/10 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Merge sort is a divide-and-conquer sorting algorithm that recursively divides the unsorted list into smaller sublists, sorts them independently, and then merges them back together to obtain the sorted list. The bottom-up approach is an iterative variant of merge sort that avoids recursive function calls.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Divide the list into sublists of size 1.",
                "step3": "Each sublist of size 1 is already sorted.",
                "step4": "Take the first pair of adjacent sublists.",
                "step5": "Merge them into a sorted sublist of size 2.",
                "step6": "Take the next pair of adjacent sublists.",
                "step7": "Merge them into another sorted sublist of size 2.",
                "step8": "Now take pairs of size 2 sublists.",
                "step9": "Merge each pair into sorted sublists of size 4.",
                "step10": "Continue with larger sublist sizes.",
                "step11": "Merge pairs of size 4 into size 8.",
                "step12": "Merge pairs of size 8 into size 16.",
                "step13": "Continue until all elements are in one sorted list.",
                "step14": "The algorithm is complete."
            },
            "timeComplexity": "Merge sort has a time complexity of O(n log n) in all cases, where n is the number of elements in the list. It is an efficient sorting algorithm and guarantees consistent performance, making it suitable for large lists. However, merge sort requires additional space to store temporary sublists during the merging process.",
            "spaceComplexity": "Merge sort has a space complexity of O(n), as it requires additional memory equal to the size of the input array to store temporary sublists during the merging process.",
            "realWorldApplications": "Merge sort is widely used in external sorting for large datasets that don't fit in memory, stable sorting requirements, and parallel processing environments. It is commonly used in programming languages' standard libraries, database systems, and file sorting applications."
        }
    }
}