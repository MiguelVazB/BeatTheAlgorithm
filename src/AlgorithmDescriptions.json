{
    "bubble_sort": {
        "description": "Bubble sort is a way to put numbers in order. You compare two numbers at a time and swap them if they're not in the right order. Keep doing this until all the numbers are in the correct order. It's like making the biggest numbers \"bubble\" to the end.",
        "instructions": "Click on the bubbles in the green area to pop them. Put them in the right order (from smallest to biggest) and Beat the Algorithm! The Reset button deletes your current attempt. Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move of the algorithm to take 500 ms or 1/2 of a second.",
            "intermediate": "Intermediate makes each move of the algorithm to take 200 ms or 1/5 of a second.",
            "hard": "Hard makes each move of the algorithm to take 100 ms or 1/10 of a second.",
            "impossible": "Impossible makes each move of the algorithm to take 10 ms or 1/100 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Bubble sort is a simple sorting algorithm that repeatedly steps through a list of elements, compares adjacent elements, and swaps them if they are in the wrong order. The algorithm gets its name from the way smaller elements \"bubble\" to the top of the list. This process is repeated until the entire list is sorted.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Compare the first element with the second element. If the first element is greater than the second element, swap them. Otherwise, leave them as they are.",
                "step3": "Move to the next pair of adjacent elements and repeat step 2. Continue this process until you reach the end of the list. At this point, the largest element in the list will be at the end.",
                "step4": "Repeat steps 2 and 3 for all elements in the list except the last one, as the last element will already be in its correct position after the first pass.",
                "step5": "Repeat steps 2-4 until the entire list is sorted. Each pass will place the next largest element in its proper position.",
                "step6": "The algorithm terminates when no more swaps are needed, indicating that the list is sorted."
            },
            "timeComplexity": "Bubble sort has a time complexity of O(n^2) in the average and worst cases, where n is the number of elements in the list. It is not considered an efficient sorting algorithm for large lists."
        }
    },
    "selection_sort": {
        "description": "Selection sort is a way to put numbers in order. You find the smallest number and put it in the first position. Then, you find the next smallest number and put it in the second position. Repeat this until all the numbers are sorted.",
        "instructions": "Select a number by clicking it. This will select the value and you can put it in the correct box. Put them in the right order (from smallest to biggest) and Beat the Algorithm! Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move of the algorithm to take 700 ms or 7/10 of a second.",
            "intermediate": "Intermediate makes each move of the algorithm to take 500 ms or 1/2 of a second.",
            "hard": "Hard makes each move of the algorithm to take 300 ms or 3/10 of a second.",
            "impossible": "Impossible makes each move of the algorithm to take 10 ms or 1/100 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Selection sort is a simple sorting algorithm that repeatedly finds the minimum element from the unsorted part of the list and places it at the beginning. The algorithm divides the list into two parts: the sorted part at the left end and the unsorted part at the right end. Initially, the sorted part is empty, and the entire list is unsorted.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Find the minimum element in the unsorted part of the list.",
                "step3": "Swap the minimum element with the leftmost element in the unsorted part, thus placing it in its correct position in the sorted part.",
                "step4": "Move the boundary of the sorted part one element to the right.",
                "step5": "Repeat steps 2-4 until the entire list is sorted."
            },
            "timeComplexity": "Selection sort has a time complexity of O(n^2) in the average and worst cases, where n is the number of elements in the list. Similar to bubble sort, it is not considered an efficient sorting algorithm for large lists. But, it is considered more efficient than bubble sort because of the number of swaps done by each."
        }
    },
    "heap_sort": {
        "description": "Heap sort is a comparison-based sorting algorithm that uses a min heap data structure to sort elements. It involves two main steps: building a min heap and repeatedly extracting the minimum element from the heap to place it in the sorted part of the list.",
        "instructions": "Select a number by clicking it. This will select the value and you can put it in the correct box. If there is a value in that box, that value will be put into the selection box. Put them in the right order (from smallest to biggest) and Beat the Algorithm! Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move of the algorithm to take 3 seconds.",
            "intermediate": "Intermediate makes each move of the algorithm to take 2 seconds.",
            "hard": "Hard makes each move of the algorithm to take 1 second.",
            "impossible": "Impossible makes each move of the algorithm to take 100 ms or 1/10 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Heap sort is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements. It involves two main steps: building a heap and repeatedly extracting the maximum element from the heap to place it in the sorted part of the list.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Build a min heap from the list. Rearrange the elements so that they satisfy the heap property, where each parent node is smaller than or equal to its child nodes. 1) To build the min heap, we start from the last non-leaf node and perform a \"heapify\" operation on each node, working backwards towards the root. 2) Heapify compares the node with its left and right child nodes, and if necessary, swaps the node with the smaller child. This process is repeated recursively until the heap property is satisfied.",
                "step3": "Once the min heap is built, the smallest element will be at the root of the heap.",
                "step4": "Extract the minimum element (root) from the heap and place it in the sorted part of the list.",
                "step5": "Replace the extracted element with the last element in the unsorted part of the list.",
                "step6": "Decrease the heap size by 1 to exclude the sorted element from future consideration.",
                "step7": "Perform a heapify operation on the new root element to maintain the heap property.",
                "step8": "Repeat steps 4-7 until the heap size becomes 1.",
                "step9": "The sorted list is obtained by placing the extracted elements in reverse order."
            },
            "timeComplexity": "Heap sort has a time complexity of O(n log n) in all cases, where n is the number of elements in the list. The build heap operation takes O(n) time, and each extraction of the minimum element takes O(log n) time. Since we perform these operations n times, the overall time complexity is O(n log n). Heap sort has a relatively efficient runtime, making it suitable for large lists."
        }
    },
    "merge_sort": {
        "description": "Merge sort works by dividing the list into smaller parts, sorting them individually, and then merging them back together to obtain a sorted list. It uses the idea of dividing and merging to efficiently sort the numbers.",
        "instructions": "Select a number by clicking it. This will select the value and put it in the white list of values on top. You can remove the values from the list on top by clicking it. Put them in the right order (from smallest to biggest) and Beat the Algorithm! Choose a difficulty and press start. Good Luck!",
        "difficulty": {
            "easy": "Easy makes each move of the algorithm to take 2 1/2 seconds.",
            "intermediate": "Intermediate makes each move of the algorithm to take 1 second.",
            "hard": "Hard makes each move of the algorithm to take half a second.",
            "impossible": "Impossible makes each move of the algorithm to take 100 ms or 1/10 of a second."
        },
        "detailedDescription": {
            "simpleExplanation": "Merge sort is a divide-and-conquer sorting algorithm that recursively divides the unsorted list into smaller sublists, sorts them independently, and then merges them back together to obtain the sorted list. The bottom-up approach is an iterative variant of merge sort that avoids recursive function calls.", 
            "steps": {
                "step1": "Start with an unsorted list of elements.",
                "step2": "Divide the list into sublists of size 1. Each sublist of size 1 is already considered sorted.",
                "step3": "Merge adjacent pairs of sublists to create sorted sublists of size 2.",
                "step4": "Repeat step 3, merging adjacent pairs of sorted sublists to create larger sorted sublists until there is only one sorted sublist remaining, which is the sorted list."
            },
            "timeComplexity": "Merge sort has a time complexity of O(n log n) in all cases, where n is the number of elements in the list. It is an efficient sorting algorithm and guarantees consistent performance, making it suitable for large lists. However, merge sort requires additional space to store temporary sublists during the merging process."
        }
    }
}